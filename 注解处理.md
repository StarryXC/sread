> Thinking

```

```

> Memory

#### JavaPoet

```
https://github.com/square/javapoet
```

```
androidx.annotation:annotation:
com.android.support:support-annotations:23.4.0

public class YicAnnotation {
    private final static int GET=0;
    private final static int POST=1;
    private final static int DELETE=2;
    private final static int PUT=3;
    @IntDef({GET, POST, DELETE,PUT})
    @Retention(RetentionPolicy.SOURCE)
    public @interface ReqType{}
}

 
Nullness注解
    @Nullable 参数可null
    @NonNull 参数不可null
Resource Type 注解
    @LayoutRes
    @AnimatorRes
    @AnimRes
    @AnyRes 任意资源类型
    @ArrayRes
    @AttrRes
    @BoolRes
    @ColorRes
    @DimenRes
    @DrawableRes
    @FractionRes
    @IdRes
    @IntegerRes
    @InterpolatorRes
    @IntDef
    @LongDef
    @Dimension
    @MenuRes
    @PluralsRes
    @RawRes
    @StringRes
    @StyleableRes
    @StyleRes
    @TransitionRes
    @XmlRes
    @ColorInt
    @ColorLong
Threading 注解
    @UiThread UI线程
    @MainThread 主线程
    @WorkerThread 子线程
    @BinderThread 绑定线程
Typedef 注解
    @IntDef
    @StringDef
Value Constraints注解
    @IntRange
    @FloatRange
    @Size

    集合不能为空: @Size(min=1)
    字符串最大只能有23个字符: @Size(max=23)
    数组只能有2个元素: @Size(2)
    数组的大小必须是2的倍数 (例如图形API中获取位置的x/y坐标数组: @Size(multiple=2)
Permissions 注解
    @RequiresPermission
    @RequiresPermission(Manifest.permission.SET_WALLPAPER)
    @RequiresPermission(anyOf = {
    Manifest.permission.ACCESS_COARSE_LOCATION,
    Manifest.permission.ACCESS_FINE_LOCATION}) // 至少需要权限集合中的一个
    @RequiresPermission(allOf = {
    Manifest.permission.READ_HISTORY_BOOKMARKS,
    Manifest.permission.WRITE_HISTORY_BOOKMARKS}) // 如果你同时需要多个权限

    对于intents的权限 直接在定义的intent常量字符串字段上标注权限需求
    @RequiresPermission(android.Manifest.permission.BLUETOOTH)
public static final String ACTION_REQUEST_DISCOVERABLE =
            "android.bluetooth.adapter.action.REQUEST_DISCOVERABLE";

            对于content providers的权限，你可能需要单独的标注读和写的权限访问，所以可以用@Read或者@Write标注每一个权限需求
            @RequiresPermission.Read(@RequiresPermission(READ_HISTORY_BOOKMARKS))
@RequiresPermission.Write(@RequiresPermission(WRITE_HISTORY_BOOKMARKS))
public static final Uri BOOKMARKS_URI = Uri.parse("content://browser/bookmarks");

Overriding Methods 注解
    @CallSuper
Return Values注解
    @CheckResult
    如果你的方法返回一个值，你期望调用者用这个值做些事情，那么你可以使用@CheckResult注解标注这个方法。
 这个在具体使用中用的比较少，除非特殊情况，比如在项目中对一个数据进行处理，这个处理比较耗时，我们希望调用该函数的调用者在不需要处理结果的时候，提示没有使用，酌情删除调用。
Keep：指出一个方法在被混淆的时候应该被保留。
   VisibleForTesting：可注解一个类，方法，或变量，表示有更宽松的可见性，这样它能够有更宽泛的可见性，使代码可以被测试。
Support Annotations中的注解的生命周期全部是RetentionPolicy.CLASS

IntelliJ注解

    IntelliJ，Android Studio就是基于它开发的，IntelliJ有一套它自己的注解；IntDef分析其实重用的是MagicConstant分析的代码，IntelliJ null分析其实用的是一组配置好的null注解。如果你执行Analyze > Infer Nullity…，它会试图找出所有的null约束并添加他们。这个检查有时会插入IntelliJ注解。你可以通过搜索,替换为Android注解库的注解，或者你也可以直接用IntelliJ注解。在build.gradle里或者通过Project Structure对话框的Dependencies面板都可以添加如下依赖
compile 'com.intellij:annotations:12.0'

经过查阅资料，系统了学习了Support Annotations注解，学以致用，通过这个Support Annotations可以提高代码可读性，同时可以在类加载时就可以检查一些错误，同时不会对性能有任何影响，因为Support Annotations中的注解的生命周期全部是RetentionPolicy.CLASS。接下来准备在项目中大量推广使用。
```

