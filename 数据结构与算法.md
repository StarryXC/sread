> Thinking

```
数据结构
    线性结构
        线性表
        链表
        栈
        队列
        数组
        矩阵
        广义表
    树形结构
        二叉树
    图形结构
算法
    排序算法
        快速排序
```

> Memory

```
public static String decodeUnicode(String input) {
    if (null == input) {
        return input;
    }
    int len = input.length();
    StringBuilder output = new StringBuilder(len);
    for (int x = 0; x < len; x++) {
        char ch = input.charAt(x);
        if (ch != '\\') {
            output.append(ch);
        } else {
            x++;
            if (x != len) {
                ch = input.charAt(x);
                if (ch == 'u') {
                    if (x + 5 > len) {
                        output.append(input.substring(x - 1));
                        x += 4;
                    } else {
                        String val = input.substring(x + 1, x + 5);
                        try {
                            output.append((char) Integer.parseInt(val, 16));
                        } catch (NumberFormatException e) {
                            output.append(input.substring(x - 1, x + 5));
                        }
                        x += 4;
                    }
                } else
                    output.append(ch);
            }
        }
    }
    return output.toString();
}

public static String encodeUnicode(String input) {
    if (null == input) {
        return input;
    }
    int len = input.length();
    StringBuilder output = new StringBuilder(len * 2);
    for (int x = 0; x < len; x++) {
        char ch = input.charAt(x);
        if ((ch < ' ') || (ch > '~')) {
            output.append("\\u");
            String hex = Integer.toHexString(ch);
            for (int i = 0; i < 4 - hex.length(); i++) {
                output.append('0');
            }
            output.append(hex);
        } else {
            output.append(ch);
        }
    }
    return output.toString();
}

public static String ascii2native ( String asciicode ) {
    String[] asciis = asciicode.split ("\\\\u");
    String nativeValue = asciis[0];
    try {
        for ( int i = 1; i < asciis.length; i++ ) {
            String code = asciis[i];
            nativeValue += (char) Integer.parseInt (code.substring (0, 4), 16);
            if (code.length () > 4) {
                nativeValue += code.substring (4, code.length ());
            }
        }
    } catch (NumberFormatException e) {
        return asciicode;
    }
    return nativeValue;
}

public static String formatJson(String jsonStr) {
    if (null == jsonStr || "".equals(jsonStr))
        return "";
    StringBuilder sb = new StringBuilder();
    char last = '\0';
    char current = '\0';
    int indent = 0;
    boolean isInQuotationMarks = false;
    for (int i = 0; i < jsonStr.length(); i++) {
        last = current;
        current = jsonStr.charAt(i);
        switch (current) {
            case '"':
                if (last != '\\'){
                    isInQuotationMarks = !isInQuotationMarks;
                }
                sb.append(current);
                break;
            case '{':
            case '[':
                sb.append(current);
                if (!isInQuotationMarks) {
                    sb.append('\n');
                    indent++;
                    addIndentBlank(sb, indent);
                }
                break;
            case '}':
            case ']':
                if (!isInQuotationMarks) {
                    sb.append('\n');
                    indent--;
                    addIndentBlank(sb, indent);
                }
                sb.append(current);
                break;
            case ',':
                sb.append(current);
                if (last != '\\' && !isInQuotationMarks) {
                    sb.append('\n');
                    addIndentBlank(sb, indent);
                }
                break;
            default:
                sb.append(current);
        }
    }

    return sb.toString();
}

private static void addIndentBlank(StringBuilder sb, int indent) {
    for (int i = 0; i < indent; i++) {
        sb.append('\t');
    }
}

public static String delHTMLTag(String htmlStr){
    String regEx_script="<script[^>]*?>[\\s\\S]*?<\\/script>"; //定义script的正则表达式
    String regEx_style="<style[^>]*?>[\\s\\S]*?<\\/style>"; //定义style的正则表达式
    String regEx_html="<[^>]+>"; //定义HTML标签的正则表达式
    Pattern p_script=Pattern.compile(regEx_script,Pattern.CASE_INSENSITIVE);
    Matcher m_script=p_script.matcher(htmlStr);
    htmlStr=m_script.replaceAll(""); //过滤

    Pattern p_style=Pattern.compile(regEx_style,Pattern.CASE_INSENSITIVE);
    Matcher m_style=p_style.matcher(htmlStr);
    htmlStr=m_style.replaceAll(""); //过滤style标签

    Pattern p_html=Pattern.compile(regEx_html,Pattern.CASE_INSENSITIVE);
    Matcher m_html=p_html.matcher(htmlStr);
    htmlStr=m_html.replaceAll(""); //过滤html标签

    return htmlStr; //返回文本字符串
}
public static String delSpace(String htmlStr){
    htmlStr = htmlStr.replaceAll("\n", "");
    htmlStr = htmlStr.replaceAll("\t", "");
    return htmlStr.trim(); //返回文本字符串
}

// 校验银行卡卡号
public static boolean checkBankCard(String cardId) {
    if(cardId.matches("0*")||cardId.length()<16){
        return false;
    }
    char bit = getBankCardCheckCode(cardId.substring(0, cardId.length() - 1));
    return cardId.charAt(cardId.length() - 1) == bit;
}
// 从不含校验位的银行卡卡号采用 Luhm 校验算法获得校验位
public static char getBankCardCheckCode(String nonCheckCodeCardId) {
    char[] chs = nonCheckCodeCardId.trim().toCharArray();
    int luhmSum = 0;
    for(int i = chs.length - 1, j = 0; i >= 0; i--, j++) {
        int k = chs[i] - '0';
        if(j % 2 == 0) {
            k *= 2;
            k = k / 10 + k % 10;
        }
        luhmSum += k;
    }
    return (luhmSum % 10 == 0) ? '0' : (char)((10 - luhmSum % 10) + '0');
}


```



