> Thinking

```

```

> Memory

### Java

```
JNI
native # 修饰方法 本地方法
System loadLibrary # 加载本地库

类型映射
方法签名


类型映射
jbyte jbyteArray # byte 有符号 8位
jshort jshortArray # short 有符号 16位
jint jintArray # int 有符号 32位
jlong jlongArray # long 有符号 64位
jfloat jfloatArray # float 32位
jdouble jdoubleArray # double 64位
jchar jcharArray # char 无符号 16位
jboolean jbooleanArray # boolean 无符号 8位
jobject jobjectArray
jclass # java.lang.Class
jstring # java.lang.String
jarray
void # void

方法签名
boolean   Z
byte      B
char      C
short     S
int       I
long      J
float     F
double    D
java.lang.Object  Ljava/lang/Object;
type[]    [type
method()  ()ret-type


#include "jni.h"
extern "C"
JNIEXPORT jstring JNICALL
(JNIEnv *env){
	std::string cpp_str = "Hello from C++";
	const char* c_str = cpp_str.c_str();
	jstring j_str = env->NewStringUTF(c_str);
	cpp_str = env->GetStringUTFChars(j_str, NULL);
	std::string result = cpp_str + cpp_str ;
	env->NewStringUTF(result.c_str());
	env->ReleaseStringUTFChars(fullPath_, fullPath);
	const char* cinfo = env->GetStringUTFChars(info,NULL);
}










```

#### jni.h

```
GetEnv
    GetVersion

    DefineClass
    FindClass

    FromReflectedMethod
    FromReflectedField
    ToReflectedMethod

    GetSuperclass
    IsAssignableFrom

    ToReflectedField

    Throw ThrowNew
    ExceptionOccurred ExceptionDescribe ExceptionClear FatalError
    ExceptionCheck

    PushLocalFrame PopLocalFrame

    NewGlobalRef DeleteGlobalRef
    NewLocalRef DeleteLocalRef
    NewWeakGlobalRef DeleteWeakGlobalRef
    IsSameObject
    EnsureLocalCapacity

    AllocObject
    NewObject NewObjectV NewObjectA

    GetObjectClass
    IsInstanceOf

    GetMethodID
    CallObjectMethod CallObjectMethodV CallObjectMethodA # Void Byte Short Int Long Float Double Char Boolean
    CallNonvirtualObjectMethod CallNonvirtualObjectMethodV CallNonvirtualObjectMethodA # Void Byte Short Int Long Float Double Char Boolean

    GetFieldID
    GetObjectField SetObjectField # Byte Short Int Long Float Double Char Boolean

    GetStaticMethodID
    CallStaticObjectMethod CallStaticObjectMethodV CallStaticObjectMethodA # Void Byte Short Int Long Float Double Char Boolean

    GetStaticFieldID
    GetStaticObjectField SetStaticObjectField # Byte Short Int Long Float Double Char Boolean

    NewString NewStringUTF
    GetStringLength GetStringUTFLength
    GetStringChars GetStringUTFChars
    GetStringRegion GetStringUTFRegion
    ReleaseStringChars ReleaseStringUTFChars

    GetArrayLength
    NewObjectArray # Byte Short Int Long Float Double Char Boolean
    GetObjectArrayElement
    SetObjectArrayElement

    GetIntArrayElements # Byte Short Int Long Float Double Char Boolean
    ReleaseIntArrayElements # Byte Short Int Long Float Double Char Boolean
    GetIntArrayRegion SetIntArrayRegion # Byte Short Int Long Float Double Char Boolean

    RegisterNatives UnregisterNatives

    MonitorEnter MonitorExit

    GetStringCritical ReleaseStringCritical
    GetPrimitiveArrayCritical ReleasePrimitiveArrayCritical

    NewDirectByteBuffer
    GetDirectBufferAddress
    GetDirectBufferCapacity

    GetObjectRefType
    DestroyJavaVM GetJavaVM

	AttachCurrentThread DetachCurrentThread
    AttachCurrentThreadAsDaemon
```



### Android

```
NDK 编程 jni
    Android.mk
    Application.mk

Android.mk
Application.mk

ifndef USE_FREETYPE
USE_FREETYPE := 2.4.2
endif

ifeq ($(USE_FREETYPE),2.4.2)
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_ARM_MODE := arm

LOCAL_SRC_FILES:= \
	src/base/ftbbox.c \
	src/psnames/psnames.c \
	src/pshinter/pshinter.c

LOCAL_C_INCLUDES += \
	$(LOCAL_PATH)/builds \
	$(LOCAL_PATH)/include

LOCAL_CFLAGS += -W -Wall
LOCAL_CFLAGS += -fPIC -DPIC
LOCAL_CFLAGS += "-DDARWIN_NO_CARBON"
LOCAL_CFLAGS += "-DFT2_BUILD_LIBRARY"
LOCAL_CFLAGS += "-DTT_CONFIG_OPTION_BYTECODE_INTERPRETER"
LOCAL_CFLAGS += -O2

LOCAL_MODULE:= libft2

include $(BUILD_STATIC_LIBRARY)
endif

include $(CLEAR_VARS)
LOCAL_C_INCLUDES += \
	$(LOCAL_PATH)/builds \
	$(LOCAL_PATH)/include
LOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog
LOCAL_MODULE := dxtx
LOCAL_STATIC_LIBRARIES := libft2
# for logging
LOCAL_LDLIBS    += -llog
# for native windows
LOCAL_LDLIBS    += -landroid

LOCAL_CFLAGS    += -UNDEBUG
include $(BUILD_SHARED_LIBRARY)



task ndkBuild(type: Exec) {
	def ndkDir = project.plugins.findPlugin('com.android.library').sdkHandler.getNdkFolder()
	commandLine "$ndkDir/ndk-build.cmd", '-C', 'src/main/jni',
			"NDK_OUT=$buildDir/ndk/obj",
			"NDK_APP_DST_DIR=$buildDir/ndk/libs/\$(TARGET_ARCH_ABI)"
}

task copyExeFile(type: Copy) {
	from fileTree(dir: file(buildDir.absolutePath + '/ndk/libs'), include: '**/*')
	into file('src/main/assets/')
}


```

```
Android.mk
APP_ABI := all
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

LOCAL_SRC_FILES:= VideoConvert.cpp

LOCAL_MODULE:= asdf

#LOCAL_CFLAGS += -std=c99
#LOCAL_C_INCLUDES :=
#LOCAL_STATIC_LIBRARIES :=
#LOCAL_SHARED_LIBRARIES :=

include $(BUILD_SHARED_LIBRARY)

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)
LOCAL_MODULE := freetype2-prebuilt
LOCAL_SRC_FILES := ../obj/local/$(TARGET_ARCH_ABI)/libfreetype2-static.a
include $(PREBUILT_STATIC_LIBRARY)

CLEAR_VARS
BUILD_EXECUTABLE
BUILD_SHARED_LIBRARY
BUILD_STATIC_LIBRARY
PREBUILT_SHARED_LIBRARY
PREBUILT_STATIC_LIBRARY

TARGET_ARCH
TARGET_PLATFORM
TARGET_ARCH_ABI
TARGET_ABI

LOCAL_PATH
LOCAL_MODULE
LOCAL_MODULE_FILENAME
LOCAL_SRC_FILES
LOCAL_CPP_EXTENSION
LOCAL_CPP_FEATURES
LOCAL_C_INCLUDES
LOCAL_CFLAGS
LOCAL_CPPFLAGS
LOCAL_STATIC_LIBRARIES
LOCAL_SHARED_LIBRARIES
LOCAL_WHOLE_STATIC_LIBRARIES
LOCAL_LDLIBS
LOCAL_LDFLAGS
LOCAL_ALLOW_UNDEFINED_SYMBOLS
LOCAL_ARM_MODE
LOCAL_ARM_NEON
LOCAL_DISABLE_FORMAT_STRING_CHECKS
LOCAL_EXPORT_CFLAGS
LOCAL_EXPORT_CPPFLAGS
LOCAL_EXPORT_C_INCLUDES
LOCAL_EXPORT_LDFLAGS
LOCAL_EXPORT_LDLIBS
LOCAL_SHORT_COMMANDS
LOCAL_THIN_ARCHIVE
LOCAL_FILTER_ASM
my-dir
all-subdir-makefiles
this-makefile
parent-makefile
grand-parent-makefile
import-module

Application.mk
# Android OS 放弃GCC转向了 Clang 编译器,NDK 将移除GCC
#   APP_STL  := gnustl_static 改为 APP_STL := c++_static
#   删除NDK_TOOLCHAIN or NDK_TOOLCHAIN_VERSION
#对于cmake编译
#   删除 ANDROID_TOOLCHAIN
#对于独立的toolchains
#   用clang/clang++ binaries 代替 gcc/g++

APP_PLATFORM := android-16
APP_ALLOW_MISSING_DEPS=true

APP_ABI := all,armeabi,armeabi-v7a,arm64-v8a
#APP_ABI:=armeabi arm64-v8a x86_64 x86 armeabi-v7a
#NDK_TOOLCHAIN_VERSION:=clang3.5
#APP_STL:=gnustl_static
APP_STL:=c++_static
#APP_OPTIM：= debuge


APP_ABI

APP_ASFLAGS
APP_ASMFLAGS
APP_BUILD_SCRIPT
APP_CFLAGS
APP_CLANG_TIDY
APP_CLANG_TIDY_FLAGS
APP_CONLYFLAGS
APP_CPPFLAGS
APP_CXXFLAGS
APP_DEBUG
APP_LDFLAGS
APP_MANIFEST
APP_MODULES
APP_OPTIM
APP_PLATFORM
APP_PROJECT_PATH
APP_SHORT_COMMANDS
APP_STL
APP_STRIP_MODE
APP_THIN_ARCHIVE
APP_WRAP_SH

 ## hello world JNI
// extern "C" 标识后面的用C编译 ,这里的意思是这个函数用C编译,C++为了函数重载会把参数带上,而c没有函数重载
// JNICALL表示调用约定，相当于C++的stdcall，说明调用的是本地方法
// JNIEXPORT表示函数的链接方式，当程序执行的时候从本地库文件中找函数
// 中间的jstring就是返回类型,是c++中对应java中String的类型
// JNIEnv 是对java环境的引用,并且提供了一些类型转换方法
// jobject 是调用这个函数的java对象.没发现如何使用
extern "C" JNIEXPORT jstring JNICALL Java_com_happy_fei_helloworldjni_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {
    std::string hello = "Hello from C++";
    return env->NewStringUTF(hello.c_str());
}
	
extern "C" 告诉编译器后面的按照C的风格编译.我测试下如果函数前不加extern "C"会报错
​```
java.lang.UnsatisfiedLinkError: No implementation found for java.lang.String com.happy.fei.helloworldjni.MainActivity.helloWorld(java.lang.String, java.lang.String) (tried Java_com_happy_fei_helloworldjni_MainActivity_helloWorld and Java_com_happy_fei_helloworldjni_MainActivity_helloWorld__Ljava_lang_String_2Ljava_lang_String_2)
​```
错误的信息是没有找到helloWorld函数也没有找到helloWorld(String,String)函数.
问题:什么时候可以不使用extern "C". 我这个文件是CPP啊,不过留待以后熟练了发现吧.现在还不太溜

###### 稍微难一点

```

